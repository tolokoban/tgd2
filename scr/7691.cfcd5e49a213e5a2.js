"use strict";(self.webpackChunk_tolokoban_tgd=self.webpackChunk_tolokoban_tgd||[]).push([["7691"],{6898(n,e,t){t.r(e),t.d(e,{default:()=>C});var o=t(4848),r=t(8453),a=t(6540),s=t(6671),i=t(385),l=t(2155),c=t(5039),g=t(156),d=t(8073),m=t(2839),u=t(244),p=t(7729),b=t(3172);class x extends l.TgdPainter{constructor(n){super(),this.context=n,this.data=new Float32Array([-.9,-.9,.1,1,-.9,.9,.1,1,.9,-.9,.1,1,.9,.9,.1,1,-.9,-.9,.9,1,-.9,.9,.9,1,.9,-.9,.9,1,.9,.9,.9,1]);const e=new l.TgdProgram(n.gl,{vert:new l.TgdShaderVertex({attributes:{attPosition:"vec4"},mainCode:["gl_Position = attPosition;"]}).code,frag:new l.TgdShaderFragment({outputs:{FragColor:"vec4"},mainCode:"FragColor = vec4(1, 1, 1, 0.5);"}).code});this.prg=e;const t=new l.TgdDataset({attPosition:"vec4"},{usage:"DYNAMIC_DRAW"});t.count=8,this.dataset=t;const o=new Uint8Array([0,1,0,2,0,4,1,3,1,5,2,3,2,6,3,7,4,5,4,6,5,7,6,7]),r=new l.TgdVertexArray(n.gl,e,[t],o);this.vao=r,e.debug()}delete(){this.prg.delete(),this.vao.delete()}paint(){let{context:n,data:e,prg:t,vao:o,dataset:r}=this;t.use();let{gl:a}=n;r.data=e.buffer,o.updateDataset(r),o.bind(),a.drawElements(a.LINES,24,a.UNSIGNED_BYTE,0),o.unbind()}}function y(n,e){n.camera.transfo.distance=14,n.camera.near=.01,n.camera.far=20;let t=new l.TgdTextureCube(n,{imagePosX:e.image.posX,imagePosY:e.image.posY,imagePosZ:e.image.posZ,imageNegX:e.image.negX,imageNegY:e.image.negY,imageNegZ:e.image.negZ}),o=(0,l.tgdColorMakeHueWheel)({steps:8}).map(n=>[n.R,n.G,n.B,1]),r=[0,1,2,3,4,5].map(n=>new l.TgdMaterialGlobal({color:o[n],ambientColor:t})),a=new l.TgdPainterClear(n,{color:[.3,.3,.3,1]}),s=new l.TgdPainterLOD(n,{bbox:{min:[-1.31195,-1.39747,-1.06093],max:[1.312,1.2265,1.563]},async factory(e,t,o,a){let s=await f(e,t,o,a);return s?new l.TgdPainterMeshGltf(n,{asset:s,material:r[a]}):null},subdivisions:1}),i=[0,1,2,3,4,5,6,7].map(e=>{let t=new l.TgdPainterDebugPoint(n),[r,a,s,i]=o[e];return t.color.x=r,t.color.y=a,t.color.z=s,t.color.w=i,t}),c=new l.TgdPainterGroup(i),g=new x(n);c.add(g),n.add(a,new l.TgdPainterState(n,{children:[s,c],depth:l.webglPresetDepth.less,cull:l.webglPresetCull.back}),new l.TgdPainterLogic(e=>{let[t,o,r]=[25000000000052758e-21,-1.39747,.251035],[a,s,l]=[1.312,-.08548500000000003,1.563],c=[[t,o,r],[t,s,r],[a,o,r],[a,s,r],[t,o,l],[t,s,l],[a,o,l],[a,s,l]],d=0;for(let e=0;e<8;e++){let[t,o,r,a]=n.camera.apply(c[e]),s=i[e];s.x=t,s.y=o,s.z=r,s.w=a;let{data:l}=g;l[d++]=t,l[d++]=o,l[d++]=r,l[d++]=a}})),n.inputs.keyboard.eventKeyPress.addListener(n=>{"d"===n.key&&s.debug()}),n.paint()}function w(){return(0,o.jsx)(b.A,{onReady:y,assets:{image:{posX:m,posY:u,posZ:p,negX:c,negY:g,negZ:d}},gizmo:!0,controller:{inertiaOrbit:1e3,inertiaZoom:1e3,speedZoom:.8}})}function P(n,e){return n.toString(2).padStart(e,"0")}async function f(n,e,t,o){let r=0===o?"./assets/lod/Octree.glb":`./assets/lod/Octree${P(n,o)}${P(e,o)}${P(t,o)}.glb`;return console.log("Loading LOD block:",r),await (0,l.tgdLoadGlb)(r)}let h={"Detail #1":'function init(context: TgdContext, assets: Assets) {\n	context.camera.transfo.distance = 14\n	context.camera.near = 1e-2\n	context.camera.far = 20\n	const color: ArrayNumber4 = [0.9, 0.5, 0.1, 1]\n	const skybox = new TgdTextureCube(context, {\n		imagePosX: assets.image.posX,\n		imagePosY: assets.image.posY,\n		imagePosZ: assets.image.posZ,\n		imageNegX: assets.image.negX,\n		imageNegY: assets.image.negY,\n		imageNegZ: assets.image.negZ,\n	})\n	const COLORS: ArrayNumber4[] = tgdColorMakeHueWheel({\n		steps: 8,\n	}).map((color) => [color.R, color.G, color.B, 1] as ArrayNumber4)\n	const materials = [0, 1, 2, 3, 4, 5].map(\n		(level) =>\n			new TgdMaterialGlobal({\n				color: COLORS[level],\n				ambientColor: skybox,\n			}),\n	)\n	const clear = new TgdPainterClear(context, { color: [0.3, 0.3, 0.3, 1] })\n	const bbox: {\n		min: Readonly<ArrayNumber3>\n		max: Readonly<ArrayNumber3>\n	} = {\n		min: [-1.31195, -1.39747, -1.06093],\n		max: [1.312, 1.2265, 1.563],\n	}\n	const lod = new TgdPainterLOD(context, {\n		bbox,\n		async factory(x: number, y: number, z: number, level: number) {\n			const asset: TgdDataGlb | null = await loadGLB(x, y, z, level)\n			if (!asset) return null\n\n			return new TgdPainterMeshGltf(context, {\n				asset,\n				material: materials[level],\n			})\n		},\n		subdivisions: 1,\n		// subdivisions: 3,\n		// surfaceThreshold: 0.8,\n	})\n	const points = [0, 1, 2, 3, 4, 5, 6, 7].map((i) => {\n		const point = new TgdPainterDebugPoint(context)\n		const [R, G, B, A] = COLORS[i]\n		point.color.x = R\n		point.color.y = G\n		point.color.z = B\n		point.color.w = A\n		return point\n	})\n	const group = new TgdPainterGroup(points)\n	const wireCube = new WireCube(context)\n	group.add(wireCube)\n	context.add(\n		clear,\n		new TgdPainterState(context, {\n			children: [lod, group],\n			depth: webglPresetDepth.less,\n			cull: webglPresetCull.back,\n		}),\n		new TgdPainterLogic((time) => {\n			// const { transfo } = context.camera\n			// transfo.setEulerRotation(\n			// 	Math.sin(time) * 30,\n			// 	Math.sin(time * 1.182) * 40,\n			// 	0,\n			// )\n			const bbox = {\n				min: [0.000025000000000052758, -1.39747, 0.251035],\n				max: [1.312, -0.08548500000000003, 1.563],\n			}\n			const [x0, y0, z0] = bbox.min\n			const [x1, y1, z1] = bbox.max\n			const corners: ArrayNumber3[] = [\n				[x0, y0, z0],\n				[x0, y1, z0],\n				[x1, y0, z0],\n				[x1, y1, z0],\n				[x0, y0, z1],\n				[x0, y1, z1],\n				[x1, y0, z1],\n				[x1, y1, z1],\n			]\n			let ptr = 0\n			for (let i = 0; i < 8; i++) {\n				const [x, y, z, w] = context.camera.apply(corners[i])\n				const painter = points[i]\n				painter.x = x\n				painter.y = y\n				painter.z = z\n				painter.w = w\n				const { data } = wireCube\n				data[ptr++] = x\n				data[ptr++] = y\n				data[ptr++] = z\n				data[ptr++] = w\n			}\n		}),\n	)\n	context.inputs.keyboard.eventKeyPress.addListener((evt) => {\n		if (evt.key === "d") {\n			lod.debug()\n		}\n	})\n	context.paint()\n}'};function T(){let[n,e]=a.useState(!1);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)("div",{className:"half-left",children:(0,o.jsx)(w,{})}),(0,o.jsxs)("div",{className:"half-right",children:[(0,o.jsx)("div",{children:(0,o.jsx)(s.yQN,{variant:"elevated",onClick:()=>e(!n),children:n?"Show code details":"Show full code"})}),(0,o.jsx)(i.A,{language:"tsx",value:n?'import {\n	type ArrayNumber3,\n	type ArrayNumber4,\n	type TgdContext,\n	type TgdDataGlb,\n	TgdMaterialGlobal,\n	TgdPainterClear,\n	TgdPainterDebugPoint,\n	TgdPainterGroup,\n	TgdPainterLOD,\n	TgdPainterLogic,\n	TgdPainterMeshGltf,\n	TgdPainterState,\n	TgdTextureCube,\n	tgdCalcMix,\n	tgdColorMakeHueWheel,\n	tgdLoadGlb,\n	webglPresetCull,\n	webglPresetDepth,\n} from "@tolokoban/tgd"\n\nimport NegX from "@/assets/cubemap/sky/negX.webp"\nimport NegY from "@/assets/cubemap/sky/negY.webp"\nimport NegZ from "@/assets/cubemap/sky/negZ.webp"\nimport PosX from "@/assets/cubemap/sky/posX.webp"\nimport PosY from "@/assets/cubemap/sky/posY.webp"\nimport PosZ from "@/assets/cubemap/sky/posZ.webp"\nimport View, { type Assets } from "@/components/demo/Tgd"\nimport { WireCube } from "./wire-cube"\n\nfunction init(context: TgdContext, assets: Assets) {\n	context.camera.transfo.distance = 14\n	context.camera.near = 1e-2\n	context.camera.far = 20\n	const color: ArrayNumber4 = [0.9, 0.5, 0.1, 1]\n	const skybox = new TgdTextureCube(context, {\n		imagePosX: assets.image.posX,\n		imagePosY: assets.image.posY,\n		imagePosZ: assets.image.posZ,\n		imageNegX: assets.image.negX,\n		imageNegY: assets.image.negY,\n		imageNegZ: assets.image.negZ,\n	})\n	const COLORS: ArrayNumber4[] = tgdColorMakeHueWheel({\n		steps: 8,\n	}).map((color) => [color.R, color.G, color.B, 1] as ArrayNumber4)\n	const materials = [0, 1, 2, 3, 4, 5].map(\n		(level) =>\n			new TgdMaterialGlobal({\n				color: COLORS[level],\n				ambientColor: skybox,\n			}),\n	)\n	const clear = new TgdPainterClear(context, { color: [0.3, 0.3, 0.3, 1] })\n	const bbox: {\n		min: Readonly<ArrayNumber3>\n		max: Readonly<ArrayNumber3>\n	} = {\n		min: [-1.31195, -1.39747, -1.06093],\n		max: [1.312, 1.2265, 1.563],\n	}\n	const lod = new TgdPainterLOD(context, {\n		bbox,\n		async factory(x: number, y: number, z: number, level: number) {\n			const asset: TgdDataGlb | null = await loadGLB(x, y, z, level)\n			if (!asset) return null\n\n			return new TgdPainterMeshGltf(context, {\n				asset,\n				material: materials[level],\n			})\n		},\n		subdivisions: 1,\n		// subdivisions: 3,\n		// surfaceThreshold: 0.8,\n	})\n	const points = [0, 1, 2, 3, 4, 5, 6, 7].map((i) => {\n		const point = new TgdPainterDebugPoint(context)\n		const [R, G, B, A] = COLORS[i]\n		point.color.x = R\n		point.color.y = G\n		point.color.z = B\n		point.color.w = A\n		return point\n	})\n	const group = new TgdPainterGroup(points)\n	const wireCube = new WireCube(context)\n	group.add(wireCube)\n	context.add(\n		clear,\n		new TgdPainterState(context, {\n			children: [lod, group],\n			depth: webglPresetDepth.less,\n			cull: webglPresetCull.back,\n		}),\n		new TgdPainterLogic((time) => {\n			// const { transfo } = context.camera\n			// transfo.setEulerRotation(\n			// 	Math.sin(time) * 30,\n			// 	Math.sin(time * 1.182) * 40,\n			// 	0,\n			// )\n			const bbox = {\n				min: [0.000025000000000052758, -1.39747, 0.251035],\n				max: [1.312, -0.08548500000000003, 1.563],\n			}\n			const [x0, y0, z0] = bbox.min\n			const [x1, y1, z1] = bbox.max\n			const corners: ArrayNumber3[] = [\n				[x0, y0, z0],\n				[x0, y1, z0],\n				[x1, y0, z0],\n				[x1, y1, z0],\n				[x0, y0, z1],\n				[x0, y1, z1],\n				[x1, y0, z1],\n				[x1, y1, z1],\n			]\n			let ptr = 0\n			for (let i = 0; i < 8; i++) {\n				const [x, y, z, w] = context.camera.apply(corners[i])\n				const painter = points[i]\n				painter.x = x\n				painter.y = y\n				painter.z = z\n				painter.w = w\n				const { data } = wireCube\n				data[ptr++] = x\n				data[ptr++] = y\n				data[ptr++] = z\n				data[ptr++] = w\n			}\n		}),\n	)\n	context.inputs.keyboard.eventKeyPress.addListener((evt) => {\n		if (evt.key === "d") {\n			lod.debug()\n		}\n	})\n	context.paint()\n}\n\nexport default function Demo() {\n	return (\n		<View\n			onReady={init}\n			assets={{\n				image: {\n					posX: PosX,\n					posY: PosY,\n					posZ: PosZ,\n					negX: NegX,\n					negY: NegY,\n					negZ: NegZ,\n				},\n			}}\n			gizmo\n			controller={{\n				inertiaOrbit: 1000,\n				inertiaZoom: 1000,\n				speedZoom: 0.8,\n			}}\n		/>\n	)\n}\n\nfunction toBin(value: number, level: number): string {\n	return value.toString(2).padStart(level, "0")\n}\n\nasync function loadGLB(\n	x: number,\n	y: number,\n	z: number,\n	level: number,\n): Promise<TgdDataGlb | null> {\n	const url =\n		level === 0\n			? "./assets/lod/Octree.glb"\n			: `./assets/lod/Octree${toBin(x, level)}${toBin(y, level)}${toBin(\n					z,\n					level,\n				)}.glb`\n	console.log("Loading LOD block:", url)\n	const asset = await tgdLoadGlb(url)\n	return asset\n}\n':h})]})]})}function v(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(t).filter(function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),o.forEach(function(e){var o;o=t[e],e in n?Object.defineProperty(n,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):n[e]=o})}return n}function O(n){var e=v({a:"a",h1:"h1",h2:"h2",p:"p"},(0,r.R)(),n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.h1,{children:[(0,o.jsx)(e.a,{href:"docs/classes/TgdPainterLOD.html",children:"TgdPainterLOD"})," (second demo)"]}),"\n",(0,o.jsx)(e.p,{children:"Dynamic level of details."}),"\n",(0,o.jsx)(e.h2,{children:"Example"}),"\n",(0,o.jsx)(e.p,{children:"Move the camera around to see how the mesh reacts."}),"\n",(0,o.jsx)(T,{})]})}function C(){var n,e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=v({},(0,r.R)(),t.components).wrapper;return a?(0,o.jsx)(a,(n=v({},t),e=e={children:(0,o.jsx)(O,v({},t))},Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):(function(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);t.push.apply(t,o)}return t})(Object(e)).forEach(function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}),n)):O(t)}}}]);